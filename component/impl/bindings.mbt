// Generated by moon-component
// DO NOT EDIT - this file is regenerated

///|
pub(all) struct DeleteOp {
  tbl : String
  row_id : String
} derive(Show, Eq)

///|
pub(all) struct DeleteRowOp {
  tbl : String
  row_id : String
} derive(Show, Eq)

///|
pub(all) struct EphemeralEntry {
  key : String
  val : Value
  timestamp : Double
  peer : String
} derive(Show, Eq)

///|
pub(all) struct EphemeralRemoteEntry {
  ns : String
  key : String
  val : Value
  timestamp : Double
  peer : String
} derive(Show, Eq)

///|
pub(all) struct Event {
  id : EventId
  deps : Array[EventId]
  lamport : Int
  op : RowOp
} derive(Show, Eq)

///|
pub(all) struct EventId {
  peer : String
  counter : Int
} derive(Show, Eq)

///|
pub(all) struct EventRun {
  peer : String
  counter_start : Int
  lamport_start : Int
  deps : Array[EventId]
  ops : Array[RowOp]
} derive(Show, Eq)

///|
pub(all) struct InsertOp {
  tbl : String
  row_id : String
  values : Array[KeyValue]
} derive(Show, Eq)

///|
pub(all) struct InsertRowOp {
  tbl : String
  row_id : String
  values : Array[KeyValue]
} derive(Show, Eq)

///|
pub(all) struct KeyValue {
  key : String
  val : Value
} derive(Show, Eq)

///|
pub(all) enum MergeOp {
  SetCell(SetCellOp)
  InsertRow(InsertRowOp)
  DeleteRow(DeleteRowOp)
} derive(Show, Eq)

///|
pub(all) struct PeerVersion {
  peer : String
  version : Int
} derive(Show, Eq)

///|
pub(all) enum RowOp {
  Insert(InsertOp)
  Update(UpdateOp)
  Delete(DeleteOp)
} derive(Show, Eq)

///|
pub(all) struct SetCellOp {
  tbl : String
  row_id : String
  col : String
  val : Value
} derive(Show, Eq)

///|
pub(all) struct SyncState {
  frontier : Array[EventId]
  versions : Array[PeerVersion]
} derive(Show, Eq)

///|
pub(all) struct UpdateOp {
  tbl : String
  row_id : String
  col : String
  val : Value
} derive(Show, Eq)

///|
pub(all) enum Value {
  ValNull
  ValBool(Bool)
  ValInt(Int)
  ValFloat(Double)
  ValStr(String)
} derive(Show, Eq)

///| Re-export cabi_realloc for wasm linking
pub fn cabi_realloc(
  old_ptr : Int,
  old_size : Int,
  align : Int,
  new_size : Int,
) -> Int {
  @cabi.cabi_realloc(old_ptr, old_size, align, new_size)
}

pub fn wasmExportCreateDoc(peer_id_ptr : Int, peer_id_len : Int) -> Int {
  let peer_id = @cabi.cabi_lift_string(peer_id_ptr, peer_id_len)
  create_doc(peer_id).reinterpret_as_int()
}

pub fn wasmExportDocDelete(handle : Int, tbl_ptr : Int, tbl_len : Int, row_id_ptr : Int, row_id_len : Int) -> Int {
  let tbl = @cabi.cabi_lift_string(tbl_ptr, tbl_len)
  let row_id = @cabi.cabi_lift_string(row_id_ptr, row_id_len)
  let result = doc_delete(handle.reinterpret_as_uint(), tbl, row_id)
  let retptr = @cabi.cabi_realloc(0, 0, 4, 72)
  // Lower record to linear memory
      let (str_ptr, str_len) = @cabi.cabi_lower_string(result.id.peer)
      @cabi.cabi_write_i32(retptr + 0, str_ptr)
      @cabi.cabi_write_i32(retptr + 0 + 4, str_len)
      @cabi.cabi_write_i32(retptr + 0 + 8, result.id.counter)
      let len = result.deps.length()
      let elem_size = 12
      let ptr = @cabi.cabi_realloc(0, 0, 4, len * elem_size)
      for i, elem in result.deps {
        let elem_ptr = ptr + i * elem_size
    let (str_ptr, str_len) = @cabi.cabi_lower_string(elem.peer)
    @cabi.cabi_write_i32(elem_ptr, str_ptr)
    @cabi.cabi_write_i32(elem_ptr + 4, str_len)
    @cabi.cabi_write_i32(elem_ptr + 8, elem.counter)
      }
      @cabi.cabi_write_i32(retptr + 12, ptr)
      @cabi.cabi_write_i32(retptr + 12 + 4, len)
      @cabi.cabi_write_i32(retptr + 20, result.lamport)
      match result.op {
        Insert(payload) => {
          @cabi.cabi_write_u8(retptr + 24, (0).to_byte())
          let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.tbl)
          @cabi.cabi_write_i32(retptr + 24 + 8, str_ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 4, str_len)
          let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.row_id)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 8, str_ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 8 + 4, str_len)
          let len = payload.values.length()
          let elem_size = 24
          let ptr = @cabi.cabi_realloc(0, 0, 8, len * elem_size)
          for i, elem in payload.values {
            let elem_ptr = ptr + i * elem_size
    let (str_ptr, str_len) = @cabi.cabi_lower_string(elem.key)
    @cabi.cabi_write_i32(elem_ptr, str_ptr)
    @cabi.cabi_write_i32(elem_ptr + 4, str_len)
    match elem.val {
      ValNull => @cabi.cabi_write_u8(elem_ptr + 8, (0).to_byte())
      ValBool(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (1).to_byte())
        @cabi.cabi_write_u8(elem_ptr + 8 + 8, if payload { b'\x01' } else { b'\x00' })
      }
      ValInt(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (2).to_byte())
        @cabi.cabi_write_i32(elem_ptr + 8 + 8, payload)
      }
      ValFloat(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (3).to_byte())
        @cabi.cabi_write_f64(elem_ptr + 8 + 8, payload)
      }
      ValStr(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (4).to_byte())
        let (str_ptr, str_len) = @cabi.cabi_lower_string(payload)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8, str_ptr)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8 + 4, str_len)
      }
    }
          }
          @cabi.cabi_write_i32(retptr + 24 + 8 + 16, ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 16 + 4, len)
        }
        Update(payload) => {
          @cabi.cabi_write_u8(retptr + 24, (1).to_byte())
          let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.tbl)
          @cabi.cabi_write_i32(retptr + 24 + 8, str_ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 4, str_len)
          let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.row_id)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 8, str_ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 8 + 4, str_len)
          let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.col)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 16, str_ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 16 + 4, str_len)
          match payload.val {
            ValNull => @cabi.cabi_write_u8(retptr + 24 + 8 + 24, (0).to_byte())
            ValBool(payload) => {
              @cabi.cabi_write_u8(retptr + 24 + 8 + 24, (1).to_byte())
              @cabi.cabi_write_u8(retptr + 24 + 8 + 24 + 8, if payload { b'\x01' } else { b'\x00' })
            }
            ValInt(payload) => {
              @cabi.cabi_write_u8(retptr + 24 + 8 + 24, (2).to_byte())
              @cabi.cabi_write_i32(retptr + 24 + 8 + 24 + 8, payload)
            }
            ValFloat(payload) => {
              @cabi.cabi_write_u8(retptr + 24 + 8 + 24, (3).to_byte())
              @cabi.cabi_write_f64(retptr + 24 + 8 + 24 + 8, payload)
            }
            ValStr(payload) => {
              @cabi.cabi_write_u8(retptr + 24 + 8 + 24, (4).to_byte())
              let (str_ptr, str_len) = @cabi.cabi_lower_string(payload)
              @cabi.cabi_write_i32(retptr + 24 + 8 + 24 + 8, str_ptr)
              @cabi.cabi_write_i32(retptr + 24 + 8 + 24 + 8 + 4, str_len)
            }
          }
        }
        Delete(payload) => {
          @cabi.cabi_write_u8(retptr + 24, (2).to_byte())
          let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.tbl)
          @cabi.cabi_write_i32(retptr + 24 + 8, str_ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 4, str_len)
          let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.row_id)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 8, str_ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 8 + 4, str_len)
        }
      }
  retptr
}

pub fn wasmExportDocGetPending(handle : Int, known_ptr : Int, known_len : Int) -> Int {
  let known : Array[PeerVersion] = {
    let arr : Array[PeerVersion] = Array::new(capacity=known_len)
    for i = 0; i < known_len; i = i + 1 {
      let elem_ptr = known_ptr + i * 12
      arr.push(({ peer: @cabi.cabi_lift_string(@cabi.cabi_read_i32(elem_ptr + 0), @cabi.cabi_read_i32(elem_ptr + 0 + 4)), version: @cabi.cabi_read_i32(elem_ptr + 8) } : PeerVersion))
    }
    arr
  }
  let result = doc_get_pending(handle.reinterpret_as_uint(), known)
  // Lower list to linear memory
  let len = result.length()
  let elem_size = 32
  let ptr = @cabi.cabi_realloc(0, 0, 4, len * elem_size)
  for i, elem in result {
    let elem_ptr = ptr + i * elem_size
    let (str_ptr, str_len) = @cabi.cabi_lower_string(elem.peer)
    @cabi.cabi_write_i32(elem_ptr, str_ptr)
    @cabi.cabi_write_i32(elem_ptr + 4, str_len)
    @cabi.cabi_write_i32(elem_ptr + 8, elem.counter_start)
    @cabi.cabi_write_i32(elem_ptr + 12, elem.lamport_start)
    let len = elem.deps.length()
    let elem_size = 12
    let ptr = @cabi.cabi_realloc(0, 0, 4, len * elem_size)
    for i, elem in elem.deps {
      let elem_ptr = ptr + i * elem_size
    let (str_ptr, str_len) = @cabi.cabi_lower_string(elem.peer)
    @cabi.cabi_write_i32(elem_ptr, str_ptr)
    @cabi.cabi_write_i32(elem_ptr + 4, str_len)
    @cabi.cabi_write_i32(elem_ptr + 8, elem.counter)
    }
    @cabi.cabi_write_i32(elem_ptr + 16, ptr)
    @cabi.cabi_write_i32(elem_ptr + 16 + 4, len)
    let len = elem.ops.length()
    let elem_size = 48
    let ptr = @cabi.cabi_realloc(0, 0, 8, len * elem_size)
    for i, elem in elem.ops {
      let elem_ptr = ptr + i * elem_size
    match elem {
      Insert(payload) => {
        @cabi.cabi_write_u8(elem_ptr, (0).to_byte())
        let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.tbl)
        @cabi.cabi_write_i32(elem_ptr + 8, str_ptr)
        @cabi.cabi_write_i32(elem_ptr + 8 + 4, str_len)
        let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.row_id)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8, str_ptr)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8 + 4, str_len)
        let len = payload.values.length()
        let elem_size = 24
        let ptr = @cabi.cabi_realloc(0, 0, 8, len * elem_size)
        for i, elem in payload.values {
          let elem_ptr = ptr + i * elem_size
    let (str_ptr, str_len) = @cabi.cabi_lower_string(elem.key)
    @cabi.cabi_write_i32(elem_ptr, str_ptr)
    @cabi.cabi_write_i32(elem_ptr + 4, str_len)
    match elem.val {
      ValNull => @cabi.cabi_write_u8(elem_ptr + 8, (0).to_byte())
      ValBool(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (1).to_byte())
        @cabi.cabi_write_u8(elem_ptr + 8 + 8, if payload { b'\x01' } else { b'\x00' })
      }
      ValInt(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (2).to_byte())
        @cabi.cabi_write_i32(elem_ptr + 8 + 8, payload)
      }
      ValFloat(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (3).to_byte())
        @cabi.cabi_write_f64(elem_ptr + 8 + 8, payload)
      }
      ValStr(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (4).to_byte())
        let (str_ptr, str_len) = @cabi.cabi_lower_string(payload)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8, str_ptr)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8 + 4, str_len)
      }
    }
        }
        @cabi.cabi_write_i32(elem_ptr + 8 + 16, ptr)
        @cabi.cabi_write_i32(elem_ptr + 8 + 16 + 4, len)
      }
      Update(payload) => {
        @cabi.cabi_write_u8(elem_ptr, (1).to_byte())
        let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.tbl)
        @cabi.cabi_write_i32(elem_ptr + 8, str_ptr)
        @cabi.cabi_write_i32(elem_ptr + 8 + 4, str_len)
        let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.row_id)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8, str_ptr)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8 + 4, str_len)
        let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.col)
        @cabi.cabi_write_i32(elem_ptr + 8 + 16, str_ptr)
        @cabi.cabi_write_i32(elem_ptr + 8 + 16 + 4, str_len)
        match payload.val {
          ValNull => @cabi.cabi_write_u8(elem_ptr + 8 + 24, (0).to_byte())
          ValBool(payload) => {
            @cabi.cabi_write_u8(elem_ptr + 8 + 24, (1).to_byte())
            @cabi.cabi_write_u8(elem_ptr + 8 + 24 + 8, if payload { b'\x01' } else { b'\x00' })
          }
          ValInt(payload) => {
            @cabi.cabi_write_u8(elem_ptr + 8 + 24, (2).to_byte())
            @cabi.cabi_write_i32(elem_ptr + 8 + 24 + 8, payload)
          }
          ValFloat(payload) => {
            @cabi.cabi_write_u8(elem_ptr + 8 + 24, (3).to_byte())
            @cabi.cabi_write_f64(elem_ptr + 8 + 24 + 8, payload)
          }
          ValStr(payload) => {
            @cabi.cabi_write_u8(elem_ptr + 8 + 24, (4).to_byte())
            let (str_ptr, str_len) = @cabi.cabi_lower_string(payload)
            @cabi.cabi_write_i32(elem_ptr + 8 + 24 + 8, str_ptr)
            @cabi.cabi_write_i32(elem_ptr + 8 + 24 + 8 + 4, str_len)
          }
        }
      }
      Delete(payload) => {
        @cabi.cabi_write_u8(elem_ptr, (2).to_byte())
        let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.tbl)
        @cabi.cabi_write_i32(elem_ptr + 8, str_ptr)
        @cabi.cabi_write_i32(elem_ptr + 8 + 4, str_len)
        let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.row_id)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8, str_ptr)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8 + 4, str_len)
      }
    }
    }
    @cabi.cabi_write_i32(elem_ptr + 24, ptr)
    @cabi.cabi_write_i32(elem_ptr + 24 + 4, len)
  }
  let retptr = @cabi.cabi_realloc(0, 0, 4, 8)
  @cabi.cabi_write_i32(retptr, ptr)
  @cabi.cabi_write_i32(retptr + 4, len)
  retptr
}

pub fn wasmExportDocInsert(handle : Int, tbl_ptr : Int, tbl_len : Int, row_id_ptr : Int, row_id_len : Int, values_ptr : Int, values_len : Int) -> Int {
  let tbl = @cabi.cabi_lift_string(tbl_ptr, tbl_len)
  let row_id = @cabi.cabi_lift_string(row_id_ptr, row_id_len)
  let values : Array[KeyValue] = {
    let arr : Array[KeyValue] = Array::new(capacity=values_len)
    for i = 0; i < values_len; i = i + 1 {
      let elem_ptr = values_ptr + i * 24
      arr.push(({ key: @cabi.cabi_lift_string(@cabi.cabi_read_i32(elem_ptr + 0), @cabi.cabi_read_i32(elem_ptr + 0 + 4)), val: (match @cabi.cabi_read_u8(elem_ptr + 8).to_int() {
        0 => ValNull
        1 => ValBool(@cabi.cabi_read_u8(elem_ptr + 8 + 8) != b'\x00')
        2 => ValInt(@cabi.cabi_read_i32(elem_ptr + 8 + 8))
        3 => ValFloat(@cabi.cabi_read_f64(elem_ptr + 8 + 8))
        4 => ValStr(@cabi.cabi_lift_string(@cabi.cabi_read_i32(elem_ptr + 8 + 8), @cabi.cabi_read_i32(elem_ptr + 8 + 8 + 4)))
        _ => abort("invalid variant discriminant")
      } : Value) } : KeyValue))
    }
    arr
  }
  let result = doc_insert(handle.reinterpret_as_uint(), tbl, row_id, values)
  let retptr = @cabi.cabi_realloc(0, 0, 4, 72)
  // Lower record to linear memory
      let (str_ptr, str_len) = @cabi.cabi_lower_string(result.id.peer)
      @cabi.cabi_write_i32(retptr + 0, str_ptr)
      @cabi.cabi_write_i32(retptr + 0 + 4, str_len)
      @cabi.cabi_write_i32(retptr + 0 + 8, result.id.counter)
      let len = result.deps.length()
      let elem_size = 12
      let ptr = @cabi.cabi_realloc(0, 0, 4, len * elem_size)
      for i, elem in result.deps {
        let elem_ptr = ptr + i * elem_size
    let (str_ptr, str_len) = @cabi.cabi_lower_string(elem.peer)
    @cabi.cabi_write_i32(elem_ptr, str_ptr)
    @cabi.cabi_write_i32(elem_ptr + 4, str_len)
    @cabi.cabi_write_i32(elem_ptr + 8, elem.counter)
      }
      @cabi.cabi_write_i32(retptr + 12, ptr)
      @cabi.cabi_write_i32(retptr + 12 + 4, len)
      @cabi.cabi_write_i32(retptr + 20, result.lamport)
      match result.op {
        Insert(payload) => {
          @cabi.cabi_write_u8(retptr + 24, (0).to_byte())
          let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.tbl)
          @cabi.cabi_write_i32(retptr + 24 + 8, str_ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 4, str_len)
          let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.row_id)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 8, str_ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 8 + 4, str_len)
          let len = payload.values.length()
          let elem_size = 24
          let ptr = @cabi.cabi_realloc(0, 0, 8, len * elem_size)
          for i, elem in payload.values {
            let elem_ptr = ptr + i * elem_size
    let (str_ptr, str_len) = @cabi.cabi_lower_string(elem.key)
    @cabi.cabi_write_i32(elem_ptr, str_ptr)
    @cabi.cabi_write_i32(elem_ptr + 4, str_len)
    match elem.val {
      ValNull => @cabi.cabi_write_u8(elem_ptr + 8, (0).to_byte())
      ValBool(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (1).to_byte())
        @cabi.cabi_write_u8(elem_ptr + 8 + 8, if payload { b'\x01' } else { b'\x00' })
      }
      ValInt(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (2).to_byte())
        @cabi.cabi_write_i32(elem_ptr + 8 + 8, payload)
      }
      ValFloat(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (3).to_byte())
        @cabi.cabi_write_f64(elem_ptr + 8 + 8, payload)
      }
      ValStr(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (4).to_byte())
        let (str_ptr, str_len) = @cabi.cabi_lower_string(payload)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8, str_ptr)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8 + 4, str_len)
      }
    }
          }
          @cabi.cabi_write_i32(retptr + 24 + 8 + 16, ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 16 + 4, len)
        }
        Update(payload) => {
          @cabi.cabi_write_u8(retptr + 24, (1).to_byte())
          let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.tbl)
          @cabi.cabi_write_i32(retptr + 24 + 8, str_ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 4, str_len)
          let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.row_id)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 8, str_ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 8 + 4, str_len)
          let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.col)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 16, str_ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 16 + 4, str_len)
          match payload.val {
            ValNull => @cabi.cabi_write_u8(retptr + 24 + 8 + 24, (0).to_byte())
            ValBool(payload) => {
              @cabi.cabi_write_u8(retptr + 24 + 8 + 24, (1).to_byte())
              @cabi.cabi_write_u8(retptr + 24 + 8 + 24 + 8, if payload { b'\x01' } else { b'\x00' })
            }
            ValInt(payload) => {
              @cabi.cabi_write_u8(retptr + 24 + 8 + 24, (2).to_byte())
              @cabi.cabi_write_i32(retptr + 24 + 8 + 24 + 8, payload)
            }
            ValFloat(payload) => {
              @cabi.cabi_write_u8(retptr + 24 + 8 + 24, (3).to_byte())
              @cabi.cabi_write_f64(retptr + 24 + 8 + 24 + 8, payload)
            }
            ValStr(payload) => {
              @cabi.cabi_write_u8(retptr + 24 + 8 + 24, (4).to_byte())
              let (str_ptr, str_len) = @cabi.cabi_lower_string(payload)
              @cabi.cabi_write_i32(retptr + 24 + 8 + 24 + 8, str_ptr)
              @cabi.cabi_write_i32(retptr + 24 + 8 + 24 + 8 + 4, str_len)
            }
          }
        }
        Delete(payload) => {
          @cabi.cabi_write_u8(retptr + 24, (2).to_byte())
          let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.tbl)
          @cabi.cabi_write_i32(retptr + 24 + 8, str_ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 4, str_len)
          let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.row_id)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 8, str_ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 8 + 4, str_len)
        }
      }
  retptr
}

pub fn wasmExportDocMergeRemote(handle : Int, events_ptr : Int, events_len : Int) -> Int {
  let events : Array[EventRun] = {
    let arr : Array[EventRun] = Array::new(capacity=events_len)
    for i = 0; i < events_len; i = i + 1 {
      let elem_ptr = events_ptr + i * 32
      arr.push(({ peer: @cabi.cabi_lift_string(@cabi.cabi_read_i32(elem_ptr + 0), @cabi.cabi_read_i32(elem_ptr + 0 + 4)), counter_start: @cabi.cabi_read_i32(elem_ptr + 8), lamport_start: @cabi.cabi_read_i32(elem_ptr + 12), deps: ({ let lp0 = @cabi.cabi_read_i32(elem_ptr + 16); let ll0 = @cabi.cabi_read_i32(elem_ptr + 16 + 4); let la0 : Array[EventId] = Array::new(capacity=ll0); for li0 = 0; li0 < ll0; li0 = li0 + 1 { la0.push(({ peer: @cabi.cabi_lift_string(@cabi.cabi_read_i32(lp0 + li0 * 12 + 0), @cabi.cabi_read_i32(lp0 + li0 * 12 + 0 + 4)), counter: @cabi.cabi_read_i32(lp0 + li0 * 12 + 8) } : EventId)) }; la0 }), ops: ({ let lp0 = @cabi.cabi_read_i32(elem_ptr + 24); let ll0 = @cabi.cabi_read_i32(elem_ptr + 24 + 4); let la0 : Array[RowOp] = Array::new(capacity=ll0); for li0 = 0; li0 < ll0; li0 = li0 + 1 { la0.push((match @cabi.cabi_read_u8(lp0 + li0 * 48).to_int() {
        0 => Insert(({ tbl: @cabi.cabi_lift_string(@cabi.cabi_read_i32(lp0 + li0 * 48 + 8 + 0), @cabi.cabi_read_i32(lp0 + li0 * 48 + 8 + 0 + 4)), row_id: @cabi.cabi_lift_string(@cabi.cabi_read_i32(lp0 + li0 * 48 + 8 + 8), @cabi.cabi_read_i32(lp0 + li0 * 48 + 8 + 8 + 4)), values: ({ let lp1 = @cabi.cabi_read_i32(lp0 + li0 * 48 + 8 + 16); let ll1 = @cabi.cabi_read_i32(lp0 + li0 * 48 + 8 + 16 + 4); let la1 : Array[KeyValue] = Array::new(capacity=ll1); for li1 = 0; li1 < ll1; li1 = li1 + 1 { la1.push(({ key: @cabi.cabi_lift_string(@cabi.cabi_read_i32(lp1 + li1 * 24 + 0), @cabi.cabi_read_i32(lp1 + li1 * 24 + 0 + 4)), val: (match @cabi.cabi_read_u8(lp1 + li1 * 24 + 8).to_int() {
        0 => ValNull
        1 => ValBool(@cabi.cabi_read_u8(lp1 + li1 * 24 + 8 + 8) != b'\x00')
        2 => ValInt(@cabi.cabi_read_i32(lp1 + li1 * 24 + 8 + 8))
        3 => ValFloat(@cabi.cabi_read_f64(lp1 + li1 * 24 + 8 + 8))
        4 => ValStr(@cabi.cabi_lift_string(@cabi.cabi_read_i32(lp1 + li1 * 24 + 8 + 8), @cabi.cabi_read_i32(lp1 + li1 * 24 + 8 + 8 + 4)))
        _ => abort("invalid variant discriminant")
      } : Value) } : KeyValue)) }; la1 }) } : InsertOp))
        1 => Update(({ tbl: @cabi.cabi_lift_string(@cabi.cabi_read_i32(lp0 + li0 * 48 + 8 + 0), @cabi.cabi_read_i32(lp0 + li0 * 48 + 8 + 0 + 4)), row_id: @cabi.cabi_lift_string(@cabi.cabi_read_i32(lp0 + li0 * 48 + 8 + 8), @cabi.cabi_read_i32(lp0 + li0 * 48 + 8 + 8 + 4)), col: @cabi.cabi_lift_string(@cabi.cabi_read_i32(lp0 + li0 * 48 + 8 + 16), @cabi.cabi_read_i32(lp0 + li0 * 48 + 8 + 16 + 4)), val: (match @cabi.cabi_read_u8(lp0 + li0 * 48 + 8 + 24).to_int() {
        0 => ValNull
        1 => ValBool(@cabi.cabi_read_u8(lp0 + li0 * 48 + 8 + 24 + 8) != b'\x00')
        2 => ValInt(@cabi.cabi_read_i32(lp0 + li0 * 48 + 8 + 24 + 8))
        3 => ValFloat(@cabi.cabi_read_f64(lp0 + li0 * 48 + 8 + 24 + 8))
        4 => ValStr(@cabi.cabi_lift_string(@cabi.cabi_read_i32(lp0 + li0 * 48 + 8 + 24 + 8), @cabi.cabi_read_i32(lp0 + li0 * 48 + 8 + 24 + 8 + 4)))
        _ => abort("invalid variant discriminant")
      } : Value) } : UpdateOp))
        2 => Delete(({ tbl: @cabi.cabi_lift_string(@cabi.cabi_read_i32(lp0 + li0 * 48 + 8 + 0), @cabi.cabi_read_i32(lp0 + li0 * 48 + 8 + 0 + 4)), row_id: @cabi.cabi_lift_string(@cabi.cabi_read_i32(lp0 + li0 * 48 + 8 + 8), @cabi.cabi_read_i32(lp0 + li0 * 48 + 8 + 8 + 4)) } : DeleteOp))
        _ => abort("invalid variant discriminant")
      } : RowOp)) }; la0 }) } : EventRun))
    }
    arr
  }
  let result = doc_merge_remote(handle.reinterpret_as_uint(), events)
  // Lower list to linear memory
  let len = result.length()
  let elem_size = 48
  let ptr = @cabi.cabi_realloc(0, 0, 8, len * elem_size)
  for i, elem in result {
    let elem_ptr = ptr + i * elem_size
    match elem {
      SetCell(payload) => {
        @cabi.cabi_write_u8(elem_ptr, (0).to_byte())
        let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.tbl)
        @cabi.cabi_write_i32(elem_ptr + 8, str_ptr)
        @cabi.cabi_write_i32(elem_ptr + 8 + 4, str_len)
        let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.row_id)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8, str_ptr)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8 + 4, str_len)
        let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.col)
        @cabi.cabi_write_i32(elem_ptr + 8 + 16, str_ptr)
        @cabi.cabi_write_i32(elem_ptr + 8 + 16 + 4, str_len)
        match payload.val {
          ValNull => @cabi.cabi_write_u8(elem_ptr + 8 + 24, (0).to_byte())
          ValBool(payload) => {
            @cabi.cabi_write_u8(elem_ptr + 8 + 24, (1).to_byte())
            @cabi.cabi_write_u8(elem_ptr + 8 + 24 + 8, if payload { b'\x01' } else { b'\x00' })
          }
          ValInt(payload) => {
            @cabi.cabi_write_u8(elem_ptr + 8 + 24, (2).to_byte())
            @cabi.cabi_write_i32(elem_ptr + 8 + 24 + 8, payload)
          }
          ValFloat(payload) => {
            @cabi.cabi_write_u8(elem_ptr + 8 + 24, (3).to_byte())
            @cabi.cabi_write_f64(elem_ptr + 8 + 24 + 8, payload)
          }
          ValStr(payload) => {
            @cabi.cabi_write_u8(elem_ptr + 8 + 24, (4).to_byte())
            let (str_ptr, str_len) = @cabi.cabi_lower_string(payload)
            @cabi.cabi_write_i32(elem_ptr + 8 + 24 + 8, str_ptr)
            @cabi.cabi_write_i32(elem_ptr + 8 + 24 + 8 + 4, str_len)
          }
        }
      }
      InsertRow(payload) => {
        @cabi.cabi_write_u8(elem_ptr, (1).to_byte())
        let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.tbl)
        @cabi.cabi_write_i32(elem_ptr + 8, str_ptr)
        @cabi.cabi_write_i32(elem_ptr + 8 + 4, str_len)
        let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.row_id)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8, str_ptr)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8 + 4, str_len)
        let len = payload.values.length()
        let elem_size = 24
        let ptr = @cabi.cabi_realloc(0, 0, 8, len * elem_size)
        for i, elem in payload.values {
          let elem_ptr = ptr + i * elem_size
    let (str_ptr, str_len) = @cabi.cabi_lower_string(elem.key)
    @cabi.cabi_write_i32(elem_ptr, str_ptr)
    @cabi.cabi_write_i32(elem_ptr + 4, str_len)
    match elem.val {
      ValNull => @cabi.cabi_write_u8(elem_ptr + 8, (0).to_byte())
      ValBool(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (1).to_byte())
        @cabi.cabi_write_u8(elem_ptr + 8 + 8, if payload { b'\x01' } else { b'\x00' })
      }
      ValInt(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (2).to_byte())
        @cabi.cabi_write_i32(elem_ptr + 8 + 8, payload)
      }
      ValFloat(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (3).to_byte())
        @cabi.cabi_write_f64(elem_ptr + 8 + 8, payload)
      }
      ValStr(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (4).to_byte())
        let (str_ptr, str_len) = @cabi.cabi_lower_string(payload)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8, str_ptr)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8 + 4, str_len)
      }
    }
        }
        @cabi.cabi_write_i32(elem_ptr + 8 + 16, ptr)
        @cabi.cabi_write_i32(elem_ptr + 8 + 16 + 4, len)
      }
      DeleteRow(payload) => {
        @cabi.cabi_write_u8(elem_ptr, (2).to_byte())
        let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.tbl)
        @cabi.cabi_write_i32(elem_ptr + 8, str_ptr)
        @cabi.cabi_write_i32(elem_ptr + 8 + 4, str_len)
        let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.row_id)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8, str_ptr)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8 + 4, str_len)
      }
    }
  }
  let retptr = @cabi.cabi_realloc(0, 0, 4, 8)
  @cabi.cabi_write_i32(retptr, ptr)
  @cabi.cabi_write_i32(retptr + 4, len)
  retptr
}

pub fn wasmExportDocSyncState(handle : Int) -> Int {
  let result = doc_sync_state(handle.reinterpret_as_uint())
  let retptr = @cabi.cabi_realloc(0, 0, 4, 16)
  // Lower record to linear memory
      let len = result.frontier.length()
      let elem_size = 12
      let ptr = @cabi.cabi_realloc(0, 0, 4, len * elem_size)
      for i, elem in result.frontier {
        let elem_ptr = ptr + i * elem_size
    let (str_ptr, str_len) = @cabi.cabi_lower_string(elem.peer)
    @cabi.cabi_write_i32(elem_ptr, str_ptr)
    @cabi.cabi_write_i32(elem_ptr + 4, str_len)
    @cabi.cabi_write_i32(elem_ptr + 8, elem.counter)
      }
      @cabi.cabi_write_i32(retptr + 0, ptr)
      @cabi.cabi_write_i32(retptr + 0 + 4, len)
      let len = result.versions.length()
      let elem_size = 12
      let ptr = @cabi.cabi_realloc(0, 0, 4, len * elem_size)
      for i, elem in result.versions {
        let elem_ptr = ptr + i * elem_size
    let (str_ptr, str_len) = @cabi.cabi_lower_string(elem.peer)
    @cabi.cabi_write_i32(elem_ptr, str_ptr)
    @cabi.cabi_write_i32(elem_ptr + 4, str_len)
    @cabi.cabi_write_i32(elem_ptr + 8, elem.version)
      }
      @cabi.cabi_write_i32(retptr + 8, ptr)
      @cabi.cabi_write_i32(retptr + 8 + 4, len)
  retptr
}

pub fn wasmExportDocUpdate(handle : Int, tbl_ptr : Int, tbl_len : Int, row_id_ptr : Int, row_id_len : Int, col_ptr : Int, col_len : Int, val_disc : Int, val_p0 : Int64, val_p1 : Int) -> Int {
  let tbl = @cabi.cabi_lift_string(tbl_ptr, tbl_len)
  let row_id = @cabi.cabi_lift_string(row_id_ptr, row_id_len)
  let col = @cabi.cabi_lift_string(col_ptr, col_len)
  let val : Value = match val_disc {
    0 => ValNull
    1 => ValBool(val_p0.to_int() != 0)
    2 => ValInt(val_p0.to_int())
    3 => ValFloat(val_p0.reinterpret_as_double())
    4 => ValStr(@cabi.cabi_lift_string(val_p0.to_int(), val_p1))
    _ => abort("invalid variant discriminant")
  }
  let result = doc_update(handle.reinterpret_as_uint(), tbl, row_id, col, val)
  let retptr = @cabi.cabi_realloc(0, 0, 4, 72)
  // Lower record to linear memory
      let (str_ptr, str_len) = @cabi.cabi_lower_string(result.id.peer)
      @cabi.cabi_write_i32(retptr + 0, str_ptr)
      @cabi.cabi_write_i32(retptr + 0 + 4, str_len)
      @cabi.cabi_write_i32(retptr + 0 + 8, result.id.counter)
      let len = result.deps.length()
      let elem_size = 12
      let ptr = @cabi.cabi_realloc(0, 0, 4, len * elem_size)
      for i, elem in result.deps {
        let elem_ptr = ptr + i * elem_size
    let (str_ptr, str_len) = @cabi.cabi_lower_string(elem.peer)
    @cabi.cabi_write_i32(elem_ptr, str_ptr)
    @cabi.cabi_write_i32(elem_ptr + 4, str_len)
    @cabi.cabi_write_i32(elem_ptr + 8, elem.counter)
      }
      @cabi.cabi_write_i32(retptr + 12, ptr)
      @cabi.cabi_write_i32(retptr + 12 + 4, len)
      @cabi.cabi_write_i32(retptr + 20, result.lamport)
      match result.op {
        Insert(payload) => {
          @cabi.cabi_write_u8(retptr + 24, (0).to_byte())
          let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.tbl)
          @cabi.cabi_write_i32(retptr + 24 + 8, str_ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 4, str_len)
          let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.row_id)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 8, str_ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 8 + 4, str_len)
          let len = payload.values.length()
          let elem_size = 24
          let ptr = @cabi.cabi_realloc(0, 0, 8, len * elem_size)
          for i, elem in payload.values {
            let elem_ptr = ptr + i * elem_size
    let (str_ptr, str_len) = @cabi.cabi_lower_string(elem.key)
    @cabi.cabi_write_i32(elem_ptr, str_ptr)
    @cabi.cabi_write_i32(elem_ptr + 4, str_len)
    match elem.val {
      ValNull => @cabi.cabi_write_u8(elem_ptr + 8, (0).to_byte())
      ValBool(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (1).to_byte())
        @cabi.cabi_write_u8(elem_ptr + 8 + 8, if payload { b'\x01' } else { b'\x00' })
      }
      ValInt(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (2).to_byte())
        @cabi.cabi_write_i32(elem_ptr + 8 + 8, payload)
      }
      ValFloat(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (3).to_byte())
        @cabi.cabi_write_f64(elem_ptr + 8 + 8, payload)
      }
      ValStr(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (4).to_byte())
        let (str_ptr, str_len) = @cabi.cabi_lower_string(payload)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8, str_ptr)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8 + 4, str_len)
      }
    }
          }
          @cabi.cabi_write_i32(retptr + 24 + 8 + 16, ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 16 + 4, len)
        }
        Update(payload) => {
          @cabi.cabi_write_u8(retptr + 24, (1).to_byte())
          let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.tbl)
          @cabi.cabi_write_i32(retptr + 24 + 8, str_ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 4, str_len)
          let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.row_id)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 8, str_ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 8 + 4, str_len)
          let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.col)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 16, str_ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 16 + 4, str_len)
          match payload.val {
            ValNull => @cabi.cabi_write_u8(retptr + 24 + 8 + 24, (0).to_byte())
            ValBool(payload) => {
              @cabi.cabi_write_u8(retptr + 24 + 8 + 24, (1).to_byte())
              @cabi.cabi_write_u8(retptr + 24 + 8 + 24 + 8, if payload { b'\x01' } else { b'\x00' })
            }
            ValInt(payload) => {
              @cabi.cabi_write_u8(retptr + 24 + 8 + 24, (2).to_byte())
              @cabi.cabi_write_i32(retptr + 24 + 8 + 24 + 8, payload)
            }
            ValFloat(payload) => {
              @cabi.cabi_write_u8(retptr + 24 + 8 + 24, (3).to_byte())
              @cabi.cabi_write_f64(retptr + 24 + 8 + 24 + 8, payload)
            }
            ValStr(payload) => {
              @cabi.cabi_write_u8(retptr + 24 + 8 + 24, (4).to_byte())
              let (str_ptr, str_len) = @cabi.cabi_lower_string(payload)
              @cabi.cabi_write_i32(retptr + 24 + 8 + 24 + 8, str_ptr)
              @cabi.cabi_write_i32(retptr + 24 + 8 + 24 + 8 + 4, str_len)
            }
          }
        }
        Delete(payload) => {
          @cabi.cabi_write_u8(retptr + 24, (2).to_byte())
          let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.tbl)
          @cabi.cabi_write_i32(retptr + 24 + 8, str_ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 4, str_len)
          let (str_ptr, str_len) = @cabi.cabi_lower_string(payload.row_id)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 8, str_ptr)
          @cabi.cabi_write_i32(retptr + 24 + 8 + 8 + 4, str_len)
        }
      }
  retptr
}

pub fn wasmExportEphemeralGet(handle : Int, ns_ptr : Int, ns_len : Int, key_ptr : Int, key_len : Int) -> Int {
  let ns = @cabi.cabi_lift_string(ns_ptr, ns_len)
  let key = @cabi.cabi_lift_string(key_ptr, key_len)
  let result = ephemeral_get(handle.reinterpret_as_uint(), ns, key)
  let retptr = @cabi.cabi_realloc(0, 0, 8, 48)
  match result {
    Some(val) => {
      @cabi.cabi_write_u8(retptr, (1).to_byte()) // discriminant: Some
      let (str_ptr, str_len) = @cabi.cabi_lower_string(val.key)
      @cabi.cabi_write_i32(retptr + 8, str_ptr)
      @cabi.cabi_write_i32(retptr + 8 + 4, str_len)
      match val.val {
        ValNull => @cabi.cabi_write_u8(retptr + 8 + 8, (0).to_byte())
        ValBool(payload) => {
          @cabi.cabi_write_u8(retptr + 8 + 8, (1).to_byte())
          @cabi.cabi_write_u8(retptr + 8 + 8 + 8, if payload { b'\x01' } else { b'\x00' })
        }
        ValInt(payload) => {
          @cabi.cabi_write_u8(retptr + 8 + 8, (2).to_byte())
          @cabi.cabi_write_i32(retptr + 8 + 8 + 8, payload)
        }
        ValFloat(payload) => {
          @cabi.cabi_write_u8(retptr + 8 + 8, (3).to_byte())
          @cabi.cabi_write_f64(retptr + 8 + 8 + 8, payload)
        }
        ValStr(payload) => {
          @cabi.cabi_write_u8(retptr + 8 + 8, (4).to_byte())
          let (str_ptr, str_len) = @cabi.cabi_lower_string(payload)
          @cabi.cabi_write_i32(retptr + 8 + 8 + 8, str_ptr)
          @cabi.cabi_write_i32(retptr + 8 + 8 + 8 + 4, str_len)
        }
      }
      @cabi.cabi_write_f64(retptr + 8 + 24, val.timestamp)
      let (str_ptr, str_len) = @cabi.cabi_lower_string(val.peer)
      @cabi.cabi_write_i32(retptr + 8 + 32, str_ptr)
      @cabi.cabi_write_i32(retptr + 8 + 32 + 4, str_len)
    }
    None => @cabi.cabi_write_u8(retptr, (0).to_byte()) // discriminant: None
  }
  retptr
}

pub fn wasmExportEphemeralGetAll(handle : Int, ns_ptr : Int, ns_len : Int) -> Int {
  let ns = @cabi.cabi_lift_string(ns_ptr, ns_len)
  let result = ephemeral_get_all(handle.reinterpret_as_uint(), ns)
  // Lower list to linear memory
  let len = result.length()
  let elem_size = 40
  let ptr = @cabi.cabi_realloc(0, 0, 8, len * elem_size)
  for i, elem in result {
    let elem_ptr = ptr + i * elem_size
    let (str_ptr, str_len) = @cabi.cabi_lower_string(elem.key)
    @cabi.cabi_write_i32(elem_ptr, str_ptr)
    @cabi.cabi_write_i32(elem_ptr + 4, str_len)
    match elem.val {
      ValNull => @cabi.cabi_write_u8(elem_ptr + 8, (0).to_byte())
      ValBool(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (1).to_byte())
        @cabi.cabi_write_u8(elem_ptr + 8 + 8, if payload { b'\x01' } else { b'\x00' })
      }
      ValInt(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (2).to_byte())
        @cabi.cabi_write_i32(elem_ptr + 8 + 8, payload)
      }
      ValFloat(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (3).to_byte())
        @cabi.cabi_write_f64(elem_ptr + 8 + 8, payload)
      }
      ValStr(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 8, (4).to_byte())
        let (str_ptr, str_len) = @cabi.cabi_lower_string(payload)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8, str_ptr)
        @cabi.cabi_write_i32(elem_ptr + 8 + 8 + 4, str_len)
      }
    }
    @cabi.cabi_write_f64(elem_ptr + 24, elem.timestamp)
    let (str_ptr, str_len) = @cabi.cabi_lower_string(elem.peer)
    @cabi.cabi_write_i32(elem_ptr + 32, str_ptr)
    @cabi.cabi_write_i32(elem_ptr + 32 + 4, str_len)
  }
  let retptr = @cabi.cabi_realloc(0, 0, 4, 8)
  @cabi.cabi_write_i32(retptr, ptr)
  @cabi.cabi_write_i32(retptr + 4, len)
  retptr
}

pub fn wasmExportEphemeralMerge(handle : Int, entries_ptr : Int, entries_len : Int) -> Int {
  let entries : Array[EphemeralRemoteEntry] = {
    let arr : Array[EphemeralRemoteEntry] = Array::new(capacity=entries_len)
    for i = 0; i < entries_len; i = i + 1 {
      let elem_ptr = entries_ptr + i * 48
      arr.push(({ ns: @cabi.cabi_lift_string(@cabi.cabi_read_i32(elem_ptr + 0), @cabi.cabi_read_i32(elem_ptr + 0 + 4)), key: @cabi.cabi_lift_string(@cabi.cabi_read_i32(elem_ptr + 8), @cabi.cabi_read_i32(elem_ptr + 8 + 4)), val: (match @cabi.cabi_read_u8(elem_ptr + 16).to_int() {
        0 => ValNull
        1 => ValBool(@cabi.cabi_read_u8(elem_ptr + 16 + 8) != b'\x00')
        2 => ValInt(@cabi.cabi_read_i32(elem_ptr + 16 + 8))
        3 => ValFloat(@cabi.cabi_read_f64(elem_ptr + 16 + 8))
        4 => ValStr(@cabi.cabi_lift_string(@cabi.cabi_read_i32(elem_ptr + 16 + 8), @cabi.cabi_read_i32(elem_ptr + 16 + 8 + 4)))
        _ => abort("invalid variant discriminant")
      } : Value), timestamp: @cabi.cabi_read_f64(elem_ptr + 32), peer: @cabi.cabi_lift_string(@cabi.cabi_read_i32(elem_ptr + 40), @cabi.cabi_read_i32(elem_ptr + 40 + 4)) } : EphemeralRemoteEntry))
    }
    arr
  }
  let result = ephemeral_merge(handle.reinterpret_as_uint(), entries)
  // Lower list to linear memory
  let len = result.length()
  let elem_size = 48
  let ptr = @cabi.cabi_realloc(0, 0, 8, len * elem_size)
  for i, elem in result {
    let elem_ptr = ptr + i * elem_size
    let (str_ptr, str_len) = @cabi.cabi_lower_string(elem.ns)
    @cabi.cabi_write_i32(elem_ptr, str_ptr)
    @cabi.cabi_write_i32(elem_ptr + 4, str_len)
    let (str_ptr, str_len) = @cabi.cabi_lower_string(elem.key)
    @cabi.cabi_write_i32(elem_ptr + 8, str_ptr)
    @cabi.cabi_write_i32(elem_ptr + 8 + 4, str_len)
    match elem.val {
      ValNull => @cabi.cabi_write_u8(elem_ptr + 16, (0).to_byte())
      ValBool(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 16, (1).to_byte())
        @cabi.cabi_write_u8(elem_ptr + 16 + 8, if payload { b'\x01' } else { b'\x00' })
      }
      ValInt(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 16, (2).to_byte())
        @cabi.cabi_write_i32(elem_ptr + 16 + 8, payload)
      }
      ValFloat(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 16, (3).to_byte())
        @cabi.cabi_write_f64(elem_ptr + 16 + 8, payload)
      }
      ValStr(payload) => {
        @cabi.cabi_write_u8(elem_ptr + 16, (4).to_byte())
        let (str_ptr, str_len) = @cabi.cabi_lower_string(payload)
        @cabi.cabi_write_i32(elem_ptr + 16 + 8, str_ptr)
        @cabi.cabi_write_i32(elem_ptr + 16 + 8 + 4, str_len)
      }
    }
    @cabi.cabi_write_f64(elem_ptr + 32, elem.timestamp)
    let (str_ptr, str_len) = @cabi.cabi_lower_string(elem.peer)
    @cabi.cabi_write_i32(elem_ptr + 40, str_ptr)
    @cabi.cabi_write_i32(elem_ptr + 40 + 4, str_len)
  }
  let retptr = @cabi.cabi_realloc(0, 0, 4, 8)
  @cabi.cabi_write_i32(retptr, ptr)
  @cabi.cabi_write_i32(retptr + 4, len)
  retptr
}

pub fn wasmExportEphemeralSet(handle : Int, ns_ptr : Int, ns_len : Int, key_ptr : Int, key_len : Int, val_disc : Int, val_p0 : Int64, val_p1 : Int, timestamp : Double) -> Int {
  let ns = @cabi.cabi_lift_string(ns_ptr, ns_len)
  let key = @cabi.cabi_lift_string(key_ptr, key_len)
  let val : Value = match val_disc {
    0 => ValNull
    1 => ValBool(val_p0.to_int() != 0)
    2 => ValInt(val_p0.to_int())
    3 => ValFloat(val_p0.reinterpret_as_double())
    4 => ValStr(@cabi.cabi_lift_string(val_p0.to_int(), val_p1))
    _ => abort("invalid variant discriminant")
  }
  let result = ephemeral_set(handle.reinterpret_as_uint(), ns, key, val, timestamp)
  let retptr = @cabi.cabi_realloc(0, 0, 4, 40)
  // Lower record to linear memory
      let (str_ptr, str_len) = @cabi.cabi_lower_string(result.key)
      @cabi.cabi_write_i32(retptr + 0, str_ptr)
      @cabi.cabi_write_i32(retptr + 0 + 4, str_len)
      match result.val {
        ValNull => @cabi.cabi_write_u8(retptr + 8, (0).to_byte())
        ValBool(payload) => {
          @cabi.cabi_write_u8(retptr + 8, (1).to_byte())
          @cabi.cabi_write_u8(retptr + 8 + 8, if payload { b'\x01' } else { b'\x00' })
        }
        ValInt(payload) => {
          @cabi.cabi_write_u8(retptr + 8, (2).to_byte())
          @cabi.cabi_write_i32(retptr + 8 + 8, payload)
        }
        ValFloat(payload) => {
          @cabi.cabi_write_u8(retptr + 8, (3).to_byte())
          @cabi.cabi_write_f64(retptr + 8 + 8, payload)
        }
        ValStr(payload) => {
          @cabi.cabi_write_u8(retptr + 8, (4).to_byte())
          let (str_ptr, str_len) = @cabi.cabi_lower_string(payload)
          @cabi.cabi_write_i32(retptr + 8 + 8, str_ptr)
          @cabi.cabi_write_i32(retptr + 8 + 8 + 4, str_len)
        }
      }
      @cabi.cabi_write_f64(retptr + 24, result.timestamp)
      let (str_ptr, str_len) = @cabi.cabi_lower_string(result.peer)
      @cabi.cabi_write_i32(retptr + 32, str_ptr)
      @cabi.cabi_write_i32(retptr + 32 + 4, str_len)
  retptr
}

///|
fn main {
  ()
}
